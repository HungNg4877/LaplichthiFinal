# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Phanlichthi.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import QFileDialog, QTableWidgetItem,QMainWindow, QMessageBox
import pandas as pd
import numpy 
import math


class Ui_MainWindow(QMainWindow):
        def __init__(self):
                super().__init__()
                self.df_cbdl=None
                self.df_dspt=None
                self.df_dsnt=None
                self.MAX_SHIFTS = 60  # Số ca thi tối đa
                self.MAX_ROOMS = 35   # Số phòng thi tối đa
                self.STUDENTS_PER_ROOM = 40  # Số sinh viên tối đa trong mỗi phòng thi
                self.shift_per_day=4
                
        def setupUi(self, MainWindow):
                MainWindow.setObjectName("MainWindow")
                MainWindow.resize(1770, 838)
                self.centralwidget = QtWidgets.QWidget(MainWindow)
                self.centralwidget.setObjectName("centralwidget")
                self.Header = QtWidgets.QWidget(self.centralwidget)
                self.Header.setGeometry(QtCore.QRect(10, 10, 1751, 121))
                self.Header.setStyleSheet("background-color: rgb(240,248,255);\n"
        "    border: 2px solid black;\n"
        "    border-radius: 10px ;")
                self.Header.setObjectName("Header")
                self.label = QtWidgets.QLabel(self.Header)
                self.label.setGeometry(QtCore.QRect(10, 0, 121, 111))
                self.label.setMinimumSize(QtCore.QSize(50, 50))
                self.label.setText("")
                self.label.setPixmap(QtGui.QPixmap(":/images/Logo-DH-Kinh-te-Dai-hoc-Da-Nang-DUE.png"))
                self.label.setScaledContents(True)
                self.label.setObjectName("label")
                self.pushButton_2 = QtWidgets.QPushButton(self.Header)
                self.pushButton_2.setGeometry(QtCore.QRect(1690, 0, 61, 28))
                self.pushButton_2.setText("")
                icon = QtGui.QIcon()
                icon.addPixmap(QtGui.QPixmap(":/images/notify_icon.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
                self.pushButton_2.setIcon(icon)
                self.pushButton_2.setObjectName("pushButton_2")
                self.pushButton_3 = QtWidgets.QPushButton(self.Header)
                self.pushButton_3.setGeometry(QtCore.QRect(1630, 0, 61, 28))
                self.pushButton_3.setText("")
                icon1 = QtGui.QIcon()
                icon1.addPixmap(QtGui.QPixmap(":/images/profile.jpg"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
                self.pushButton_3.setIcon(icon1)
                self.pushButton_3.setObjectName("pushButton_3")
                self.ChonDLDCB = QtWidgets.QPushButton(self.Header)
                self.ChonDLDCB.setGeometry(QtCore.QRect(180, 30, 311, 81))
                self.ChonDLDCB.setStyleSheet("font: 16pt \"MS Shell Dlg 2\";\n"
        "background-color: rgb(248, 248, 248);\n"
        "")
                self.ChonDLDCB.setObjectName("ChonDLDCB")
                self.widget_3 = QtWidgets.QWidget(self.centralwidget)
                self.widget_3.setGeometry(QtCore.QRect(0, 140, 1771, 671))
                self.widget_3.setStyleSheet("background-color: rgb(240,248,255);")
                self.widget_3.setObjectName("widget_3")
                self.widget = QtWidgets.QWidget(self.widget_3)
                self.widget.setGeometry(QtCore.QRect(10, 0, 1751, 661))
                self.widget.setStyleSheet("background-color: rgb(240,248,255);\n"
        "    border: 2px solid black;\n"
        "    border-radius: 10px ;")
                self.widget.setObjectName("widget")
                self.textEdit = QtWidgets.QTextEdit(self.widget)
                self.textEdit.setGeometry(QtCore.QRect(840, 20, 901, 611))
                self.textEdit.setStyleSheet("background-color: rgb(248, 248, 248);")
                self.textEdit.setObjectName("textEdit")
                self.XuatraPCT = QtWidgets.QPushButton(self.widget)
                self.XuatraPCT.setGeometry(QtCore.QRect(430, 150, 401, 71))
                self.XuatraPCT.setStyleSheet("font: 12pt \"MS Shell Dlg 2\";\n"
        "background-color: rgb(248, 248, 248);")
                self.XuatraPCT.setObjectName("XuatraPCT")
                self.PCT = QtWidgets.QPushButton(self.widget)
                self.PCT.setGeometry(QtCore.QRect(50, 150, 381, 71))
                self.PCT.setStyleSheet("font: 12pt \"MS Shell Dlg 2\";\n"
        "background-color: rgb(248, 248, 248);")
                self.PCT.setObjectName("PCT")
                self.XuatraPPT = QtWidgets.QPushButton(self.widget)
                self.XuatraPPT.setGeometry(QtCore.QRect(430, 230, 401, 71))
                self.XuatraPPT.setStyleSheet("font: 12pt \"MS Shell Dlg 2\";\n"
        "background-color: rgb(248, 248, 248);")
                self.XuatraPPT.setObjectName("XuatraPPT")
                self.PPT = QtWidgets.QPushButton(self.widget)
                self.PPT.setGeometry(QtCore.QRect(50, 230, 381, 71))
                self.PPT.setStyleSheet("font: 12pt \"MS Shell Dlg 2\";\n"
        "background-color: rgb(248, 248, 248);")
                self.PPT.setObjectName("PPT")
                self.GNT = QtWidgets.QPushButton(self.widget)
                self.GNT.setGeometry(QtCore.QRect(50, 310, 381, 71))
                self.GNT.setStyleSheet("font: 12pt \"MS Shell Dlg 2\";\n"
        "background-color: rgb(248, 248, 248);")
                self.GNT.setObjectName("GNT")
                self.XuatraGNT = QtWidgets.QPushButton(self.widget)
                self.XuatraGNT.setGeometry(QtCore.QRect(430, 310, 401, 71))
                self.XuatraGNT.setStyleSheet("font: 12pt \"MS Shell Dlg 2\";\n"
        "background-color: rgb(248, 248, 248);")
                self.XuatraGNT.setObjectName("XuatraGNT")
                self.XLT = QtWidgets.QPushButton(self.widget)
                self.XLT.setGeometry(QtCore.QRect(50, 390, 381, 71))
                self.XLT.setStyleSheet("font: 12pt \"MS Shell Dlg 2\";\n"
        "background-color: rgb(248, 248, 248);")
                self.XLT.setObjectName("XLT")
                self.XuatraXLT = QtWidgets.QPushButton(self.widget)
                self.XuatraXLT.setGeometry(QtCore.QRect(430, 390, 401, 71))
                self.XuatraXLT.setStyleSheet("font: 12pt \"MS Shell Dlg 2\";\n"
        "background-color: rgb(248, 248, 248);")
                self.XuatraXLT.setObjectName("XuatraXLT")
                MainWindow.setCentralWidget(self.centralwidget)
                self.statusbar = QtWidgets.QStatusBar(MainWindow)
                self.statusbar.setObjectName("statusbar")
                MainWindow.setStatusBar(self.statusbar)
                        # Đặt kích thước chữ cho textEdit
                font = self.textEdit.font()
                font.setPointSize(16)  # Thay đổi kích thước chữ ở đây (ví dụ: 14)
                self.textEdit.setFont(font)
                #
                self.ChonDLDCB.clicked.connect(self.Load_data)
                self.PCT.clicked.connect(self.show_result_phan_ca_thi)
                self.XuatraPCT.clicked.connect(self.save_data_phancathi)
                
                self.PPT.clicked.connect(self.show_result_phan_phong_thi)
                self.XuatraPPT.clicked.connect(self.save_data_phanphongthi)
                
                self.GNT.clicked.connect(self.show_result_gan_ngay_thi)
                self.XuatraGNT.clicked.connect(self.save_data_ganngaythi)
                
                self.XLT.clicked.connect(self.show_result_Xeplichthi)
                self.XuatraXLT.clicked.connect(self.save_data_XLT)
                self.retranslateUi(MainWindow)
                QtCore.QMetaObject.connectSlotsByName(MainWindow)

        def retranslateUi(self, MainWindow):
                _translate = QtCore.QCoreApplication.translate
                MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
                self.ChonDLDCB.setText(_translate("MainWindow", "Chọn tập tin đầu vào"))
                self.XuatraPCT.setText(_translate("MainWindow", "Xuất ra tập tin phân ca thi"))
                self.PCT.setText(_translate("MainWindow", "1. Thực hiên phân ca thi"))
                self.XuatraPPT.setText(_translate("MainWindow", "Xuất ra tập tin phân phòng thi"))
                self.PPT.setText(_translate("MainWindow", "2. Thực hiện phân phòng thi"))
                self.XuatraGNT.setText(_translate("MainWindow", "Xuất ra tập tin gán ngày thi"))
                self.GNT.setText(_translate("MainWindow", "3. Thực hiện gán ngày thi"))
                self.XuatraXLT.setText(_translate("MainWindow", "Xuất ra tập tin xếp lịch thi"))
                self.XLT.setText(_translate("MainWindow", "Thực hiện xếp lịch thi"))

        def Load_data(self):
        # Yêu cầu người dùng chọn tệp dữ liệu Excel
        
                file_dialog = QFileDialog()

                file_path_1, _ = file_dialog.getOpenFileName(None, "Chọn file dữ liệu đã được xử lý ", "", "Excel Files (*.xlsx *.xls)")
                if not file_path_1:
                        QMessageBox.warning(None, "Lỗi", "Chưa chọn dữ liệu")
                        return
                df_cbdl= pd.read_excel(file_path_1)

                
                file_path_2, _ = file_dialog.getOpenFileName(None, "Chọn file dữ liệu phòng thi ", "", "Excel Files (*.xlsx *.xls)")
                if not file_path_2:
                        QMessageBox.warning(None, "Lỗi", "Chưa chọn dữ liệu")
                        return
                df_dspt= pd.read_excel(file_path_2)
                
                file_path_3, _ = file_dialog.getOpenFileName(None, "Chọn file dữ liệu ngày thi ", "", "Excel Files (*.xlsx *.xls)")
                if not file_path_3:
                        QMessageBox.warning(None, "Lỗi", "Chưa chọn dữ liệu")
                        return
                df_dsnt= pd.read_excel(file_path_3)
                self.df_cbdl=df_cbdl
                self.df_dspt=df_dspt
                self.df_dsnt=df_dsnt


        def assign_exam_schedule(self, df_cbdl, max_shifts, max_rooms, students_per_room):
                course_students = df_cbdl.groupby('Mã học phần mở rộng')['MSV mở rộng'].count()
                course_rooms = dict([[kcs, math.ceil(course_students[kcs]/students_per_room)] for kcs in course_students.keys()])
                #Xem mã học phần đó có bao nhiêu sinh viên đăng ký
                count_node = df_cbdl.groupby('Mã học phần mở rộng')['MSV mở rộng'].nunique().reset_index(name='Bậc')
                students_per_shift = students_per_room*max_rooms
                shifts = numpy.zeros(max_shifts)
                df_cbdl['Ca thi'] = numpy.nan
                # Sắp xếp các mã học phần theo slsv đăng ký
                sorted_nodes = count_node.sort_values(by='Bậc', ascending=False)['Mã học phần mở rộng'].tolist()     
                #Tạo các cạnh nối giữa các mã học phần
                edges = set()

    # Xem sinh viên đó học bao nhiêu học phần 
                for _, group in df_cbdl.groupby('MSV mở rộng'): 
                        #       
                        subjects = group['Mã học phần mở rộng'].tolist()
                        
                        #Tạo ra các cặp cạnh i,j trong danh sách subject. Các cặp này sẽ tạo thành các cạnh biễu diễn bằng giá trị i,j
                        edges.update([(subjects[i], subjects[j]) for i in range(len(subjects)) for j in range(i+1, len(subjects))])

                i = 1    
                while sorted_nodes and i <= max_shifts:
                        # Chọn đỉnh đầu tiên trong danh sách V
                        start_node = sorted_nodes[0]
                        
                        # Tô màu i cho đỉnh đang xét
                        #Số lượng sinh viên của mã học phần đầu tiên
                        no_students = len(df_cbdl.loc[df_cbdl['Mã học phần mở rộng'] == start_node, 'Ca thi'])
                        #no_students = course_students[start_node]
                        if no_students > students_per_shift:
                                if shifts[i] == 0:
                                        no_required_shifts = math.ceil(no_students/students_per_shift)
                                        no_node_students_per_shift = math.ceil(no_students/no_required_shifts)
                                        j = 0
                                        for k,r in df_cbdl.loc[df_cbdl['Mã học phần mở rộng'] == start_node].iterrows():
                                                df_cbdl.loc[k,'Ca thi'] = i+int(j/no_node_students_per_shift)
                                                j += 1
                
                                        for j in range(no_required_shifts):
                                                shifts[i+j] += math.ceil(no_node_students_per_shift/students_per_room)
                    
                                        sorted_nodes = sorted_nodes[1:]
                
                        elif no_students < students_per_shift:
            #Lọc ra các học phần còn lại
                                unassigned_course = df_cbdl[df_cbdl['Ca thi'].isnull()]['Mã học phần mở rộng'].unique()
                                new_edges = set()   
        
                                for _, group in df_cbdl[df_cbdl['Mã học phần mở rộng'].isin(unassigned_course)].groupby('MSV mở rộng'):
            # Tạo danh sách chứa các mã học phần trong nhóm hiện tại
                                        subjects = group['Mã học phần mở rộng'].tolist()
            # Tạo các cặp cạnh giữa các mã học phần trong nhóm
                                        new_edges.update([(subjects[i], subjects[j]) for i in range(len(subjects)) for j in range(i + 1, len(subjects))])
            # Tạo từ điển để lưu trữ số cạnh của mỗi node
                                node_edge_counts = {}
      
                                for edge in new_edges:
                                        for node in edge:
                    # Tăng số lượng cạnh cho node lên 1
                                                if node in node_edge_counts:
                                                        node_edge_counts[node] += 1
                                                else:       
                                                        node_edge_counts[node] = 1
            # Sắp xếp các cạnh của mỗi node theo thứ tự giảm dần
                                sorted_nodes_by_edge_count = sorted(node_edge_counts.keys(), key=lambda x: node_edge_counts[x], reverse=True)
                                if len(sorted_nodes_by_edge_count)>0:   
                                        first_node=sorted_nodes_by_edge_count[0]
               
                                        df_cbdl.loc[df_cbdl['Mã học phần mở rộng'] == first_node, 'Ca thi'] = i
                
                                        sorted_nodes_by_edge_count = sorted_nodes_by_edge_count[1:]

             
                        jn = 0
                        while jn < len(sorted_nodes):
                                node =  sorted_nodes[jn]
                        #Danh sách các đỉnh đã được tô màu i
                                colored_nodes = set(df_cbdl[df_cbdl['Ca thi'] == i]['Mã học phần mở rộng'].tolist())
                                if all((node, colored_node) not in edges and (colored_node, node) not in edges for colored_node in colored_nodes):
                                        # Nếu không kề với các học phần đã tô màu i, tô màu i cho đỉnh đó
                                        remaining_room=max_rooms-shifts[i]
                                        if course_rooms[node] <= remaining_room:                
                                                df_cbdl.loc[df_cbdl['Mã học phần mở rộng'] == node, 'Ca thi'] = i
                                                shifts[i] += course_rooms[node]
                                        #uncolored_nodes.remove(node)
                                                sorted_nodes = sorted_nodes[:jn] + sorted_nodes[jn+1:]
                                        #colored_nodes += [node]
                                                jn -= 1
                                else:
                                        print(node)
                                jn += 1
                
                        # Tăng giá trị màu i lên 1 đơn vị
                        i += 1
                return df_cbdl
        def show_result_phan_ca_thi(self):
                self.textEdit.clear()
                if self.df_cbdl is None:
                        QMessageBox.warning(None, "Lỗi", "Dữ liệu chưa được tải")
                        return
                self.df_phancathi=self.assign_exam_schedule(self.df_cbdl,self.MAX_SHIFTS,self.MAX_ROOMS,self.STUDENTS_PER_ROOM)
                num_shifts = len(self.df_phancathi['Ca thi'].unique())
                num_course= len(self.df_phancathi[self.df_phancathi['Ca thi'].notnull()]['Mã học phần mở rộng'].unique())

                stt=1
                # Hiển thị kết quả
                
                self.textEdit.insertPlainText(f"Tổng số ca thi : {num_shifts}\n")
                self.textEdit.insertPlainText(f"Tổng số học phần đã được gán ca thi : {num_course}\n")
                        # Lặp qua từng ca thi
                for shift in sorted(self.df_phancathi['Ca thi'].unique().astype(int)):
                # 
                        df_shift = self.df_phancathi[self.df_phancathi['Ca thi'] == shift]
        
                        df_course = len(df_shift['Mã học phần mở rộng'].unique())

                        # Hiển thị số phòng thi của ca thi
                        self.textEdit.insertPlainText(f"{stt}. Ca thi: {shift}, Số học phần thi trong ca thi {shift}: {df_course}\n")

                        stt+=1
                # Xuống dòng sau khi kết thúc thông tin về mỗi ngày thi
                
                self.textEdit.insertPlainText("\n")       
        def save_data_phancathi(self):
                        
                if self.df_cbdl is None:
                        QMessageBox.warning(None, "Lỗi", "Dữ liệu chưa được tải")
                        return
                elif self.df_phancathi is None:
                        QMessageBox.warning(None, "Lỗi", "Dữ liệu chưa được tải")


                file_dialog = QFileDialog()
                file_path, _ = file_dialog.getSaveFileName(None, "Lưu file", "", "Excel Files (*.xlsx *.xls)")
                if not file_path:  # Kiểm tra nếu người dùng không chọn vị trí lưu file
                        QMessageBox.warning(self, "Lỗi", "Bạn chưa chọn vị trí để lưu tập tin. Vui lòng chọn một vị trí để lưu.")
                        return

                        # Lưu dữ liệu đã xử lý ra file Excel
                self.df_phancathi.to_excel(file_path, index=False)
        def Load_data_phan_ca_thi(self):
        # Yêu cầu người dùng chọn tệp dữ liệu Excel
        
                file_dialog = QFileDialog()

                file_path, _ = file_dialog.getOpenFileName(None, "Chọn file dữ liệu đã được xử lý ", "", "Excel Files (*.xlsx *.xls)")
                if not file_path:
                        QMessageBox.warning(None, "Lỗi", "Chưa chọn dữ liệu")
                        return
                self.df_phancathi= pd.read_excel(file_path)               
        def assign_rooms(self, df_phancathi, df_dsphongthi, students_per_room):

                df_phancathi['Mã phòng'] = ""

                # Tạo danh sách các ca thi và phòng thi
                count_shifts = sorted(df_phancathi['Ca thi'].unique())
                count_rooms = df_dsphongthi['Mã phòng'].unique()
                # Tạo một từ điển để lưu trữ các phòng thi đã được gán cho mỗi ca thi
                assigned_rooms_per_shift = {shift: set() for shift in count_shifts}

                # Lặp qua từng ca thi
                for shift in count_shifts:
                # Lấy danh sách các học phần trong ca thi hiện tại
                        course_counts = df_phancathi[df_phancathi['Ca thi'] == shift].groupby('Mã học phần mở rộng')['MSV'].count()
                        sorted_courses = course_counts.sort_values(ascending=False).index.tolist()
                        # Lặp qua từng học phần trong ca thi
                        for course in sorted_courses:
                                no_students = len(df_phancathi[(df_phancathi['Mã học phần mở rộng'] == course) & (df_phancathi['Ca thi'] == shift)])

                                rooms_needed = math.ceil(no_students / students_per_room)
                                students_per_room_now=math.ceil(no_students/rooms_needed)
                        # Phân bổ sinh viên vào các phòng thi khác nhau
                                assigned_rooms = 0
                                for room in count_rooms:   
                                        if room not in assigned_rooms_per_shift[shift]:
                                                available_students = df_phancathi[(df_phancathi['Mã học phần mở rộng'] == course) & (df_phancathi['Ca thi'] == shift) & (df_phancathi['Mã phòng'] == '')]
                                                available_student_count = len(available_students)
                                                if available_student_count>0:
                                                        df_phancathi.loc[available_students.index[:students_per_room_now], 'Mã phòng'] = room
                                                        assigned_rooms_per_shift[shift].add(room)
                                                        assigned_rooms += 1
                                
                                                if assigned_rooms == rooms_needed:
                                                        break
                return df_phancathi
        def show_result_phan_phong_thi(self):
    # Xóa nội dung cũ trong textEdit trước khi hiển thị kết quả mới
                if self.df_cbdl is None:
                        QMessageBox.warning(None, "Lỗi", "Dữ liệu chưa được tải")
                        return
                self.textEdit.clear()
                self.Load_data_phan_ca_thi()
                self.df_phanphongthi=self.assign_rooms(self.df_phancathi,self.df_dspt,self.STUDENTS_PER_ROOM)
                # Đếm số ca thi của ngày thi
                num_shifts = len(self.df_phanphongthi['Ca thi'].unique())
                stt=1
                # Hiển thị kết quả
                self.textEdit.insertPlainText(f"Tổng Số ca thi : {num_shifts}\n")
                # Lặp qua từng ca thi 
                for shift in sorted(self.df_phanphongthi['Ca thi'].astype(int).unique()):
                # Lọc df_day theo ca thi hiện tại
                        df_shift = self.df_phanphongthi[self.df_phanphongthi['Ca thi'] == shift]
                #
                        df_course = len(df_shift['Mã học phần'].unique())
                # Đếm số phòng thi của ca thi
                        num_rooms = len(df_shift['Mã phòng'].unique())

                # Hiển thị số phòng thi của ca thi
                        self.textEdit.insertPlainText(f"{stt}. Ca thi: {shift}, Số học phần thi trong ca thi {shift}: {df_course}, Số phòng thi được sử dụng trong ca thi: {num_rooms}\n")

                        stt+=1
                # Xuống dòng sau khi kết thúc thông tin về mỗi ngày thi
                
                self.textEdit.insertPlainText("\n")
        def save_data_phanphongthi(self):
                      
                if self.df_cbdl is None:
                        QMessageBox.warning(None, "Lỗi", "Dữ liệu chưa được tải")
                        return
                elif self.df_phanphongthi is None:
                        QMessageBox.warning(None ,"Lỗi", "Dữ liệu chưa được tải")

                file_dialog = QFileDialog()
                file_path, _ = file_dialog.getSaveFileName(None, "Lưu file", "", "Excel Files (*.xlsx *.xls)")
                if not file_path:  # Kiểm tra nếu người dùng không chọn vị trí lưu file
                        QMessageBox.warning(self, "Lỗi", "Bạn chưa chọn vị trí để lưu tập tin. Vui lòng chọn một vị trí để lưu.")
                        return
                        # Lưu dữ liệu đã xử lý ra file Excel
                self.df_phanphongthi.to_excel(file_path, index=False)
                
        def Load_data_phan_phong_thi(self):
        # Yêu cầu người dùng chọn tệp dữ liệu Excel
        
                file_dialog = QFileDialog()

                file_path, _ = file_dialog.getOpenFileName(None, "Chọn file dữ liệu đã được xử lý ", "", "Excel Files (*.xlsx *.xls)")
                if not file_path:
                        QMessageBox.warning(None, "Lỗi", "Chưa chọn dữ liệu")
                        return
                self.df_phanphongthi= pd.read_excel(file_path)  
        def assign_calender(self, df_phanphongthi, df_dsngaythi, shift_per_day):
                df_phanphongthi['Ngày thi'] = ""
                count_shifts = sorted(df_phanphongthi['Ca thi'].unique())
                count_shifts_len=len(count_shifts)
                count_day = df_dsngaythi['Ngày thi'].unique()
                count_time=df_dsngaythi['Giờ thi'].unique().tolist()
                day_needed=math.ceil(count_shifts_len/shift_per_day)
        
        
                shifts_per_day = []
                for i in range(day_needed):
                        shifts_per_day.append(count_shifts[i * shift_per_day : (i + 1) * shift_per_day])
                assigned_day=0
                for day in (count_day):
                        if assigned_day == day_needed:
                                break
                        for shift in shifts_per_day[assigned_day]:
                                available_shifts = df_phanphongthi[(df_phanphongthi['Ca thi'] == shift) & (df_phanphongthi['Ngày thi'] == '')]

                                df_phanphongthi.loc[available_shifts.index, 'Ngày thi'] = day
                                df_phanphongthi.loc[available_shifts.index, 'Giờ thi'] = count_time[(int(shift)-1) % shift_per_day]
                        assigned_day+=1
                df_phanphongthi['Ngày thi'] = pd.to_datetime(df_phanphongthi['Ngày thi'])
                df_phanphongthi['Ngày thi'] = df_phanphongthi['Ngày thi'].dt.strftime("%d/%m/%Y")
                return df_phanphongthi
        def show_result_gan_ngay_thi(self):
                if self.df_cbdl is None:
                        QMessageBox.warning(None, "Lỗi", "Dữ liệu chưa được tải")
                        return
                self.Load_data_phan_phong_thi()
                self.df_ganngaythi=self.assign_calender(self.df_phanphongthi,self.df_dsnt,self.shift_per_day)
                # Xóa nội dung cũ trong textEdit trước khi hiển thị kết quả mới
                self.textEdit.clear()

        # Lặp qua từng ca thi trong df_1
                count_shifts = sorted(self.df_ganngaythi['Ca thi'].unique())
                count_shifts_len=len(count_shifts)
                day_needed=math.ceil(count_shifts_len/self.shift_per_day)

        # Hiển thị số ngày thi cần
                day_count = 1
                self.textEdit.insertPlainText(f"Số ngày thi: {day_needed}\n")

        # Lặp qua từng ngày thi
                for days in sorted(self.df_ganngaythi['Ngày thi'].unique()):
                # Lọc df_1 theo ngày thi hiện tại
                        df_day = self.df_ganngaythi[self.df_ganngaythi['Ngày thi'] == days]

                # Đếm số ca thi của ngày thi
                        num_shifts = len(df_day['Ca thi'].unique())

                # Hiển thị kết quả
                        self.textEdit.insertPlainText(f"{day_count}. Ngày thi: {days}\n")
                        self.textEdit.insertPlainText(f"    Số ca thi của ngày thi: {num_shifts}\n")
                        # Lặp qua từng ca thi trong ngày
                        for shift in sorted(df_day['Ca thi'].astype(int).unique()):
                # Lọc df_day theo ca thi hiện tại
                                df_shift = df_day[df_day['Ca thi'] == shift]
                                
                                df_time=df_shift['Giờ thi'].iloc[0]
                #
                                df_course = len(df_shift['Mã học phần'].unique())
                # Đếm số phòng thi của ca thi
                                num_rooms = len(df_shift['Mã phòng'].unique())

                # Hiển thị số phòng thi của ca thi
                                self.textEdit.insertPlainText(f"      Ca thi: {shift}, Giờ thi: {df_time}, Tổng số học phần thi: {df_course}, Tổng số phòng thi được sử dụng: {num_rooms}\n")

                        day_count += 1
                # Xuống dòng sau khi kết thúc thông tin về mỗi ngày thi
                
                self.textEdit.insertPlainText("\n")
        def save_data_ganngaythi(self):
                      
                if self.df_cbdl is None:
                        QMessageBox.warning(None, "Lỗi", "Dữ liệu chưa được tải")
                        return
                        # Xử lý dữ liệu


 
                file_dialog = QFileDialog()
                file_path, _ = file_dialog.getSaveFileName(None, "Lưu file", "", "Excel Files (*.xlsx *.xls)")
                if not file_path:  # Kiểm tra nếu người dùng không chọn vị trí lưu file
                        QMessageBox.warning(self, "Lỗi", "Bạn chưa chọn vị trí để lưu tập tin. Vui lòng chọn một vị trí để lưu.")
                        return

                        # Lưu dữ liệu đã xử lý ra file Excel
                self.df_ganngaythi.to_excel(file_path, index=False)

        def show_result_Xeplichthi(self):
                if self.df_cbdl is None:
                        QMessageBox.warning(None, "Lỗi", "Dữ liệu chưa được tải")
                        return
                self.df_cbdl_processed = self.df_cbdl.copy()  # Tạo bản sao của df_svthihk để tránh làm thay đổi trực tiếp trên dữ liệu gốc
                
                self.df_cbdl_processed = self.assign_exam_schedule(self.df_cbdl_processed, self.MAX_SHIFTS, self.MAX_ROOMS,self.STUDENTS_PER_ROOM)
                self.df_cbdl_processed = self.assign_rooms(self.df_cbdl_processed, self.df_dspt,self.STUDENTS_PER_ROOM)
                self.df_cbdl_processed = self.assign_calender(self.df_cbdl_processed, self.df_dsnt, self.shift_per_day)
                # Xóa nội dung cũ trong textEdit trước khi hiển thị kết quả mới
                self.textEdit.clear()

        # Lặp qua từng ca thi trong df_1
         
                count_shifts = sorted(self.df_cbdl_processed['Ca thi'].unique())
                count_shifts_len=len(count_shifts)
                day_needed=math.ceil(count_shifts_len/self.shift_per_day)

        # Hiển thị số ngày thi cần
                day_count = 1
                self.textEdit.insertPlainText(f"Tổng số ngày thi: {day_needed}\n")

        # Lặp qua từng ngày thi
                for days in sorted(self.df_cbdl_processed['Ngày thi'].unique()):

                        df_day = self.df_cbdl_processed[self.df_cbdl_processed['Ngày thi'] == days]

                # Đếm số ca thi của ngày thi
                        num_shifts = len(df_day['Ca thi'].unique())

                # Hiển thị kết quả
                        self.textEdit.insertPlainText(f"{day_count}. Ngày thi: {days}\n")
                        self.textEdit.insertPlainText(f"     Số ca thi của ngày thi: {num_shifts}\n")
                        # Lặp qua từng ca thi trong ngày
                        for shift in sorted(df_day['Ca thi'].astype(int).unique()):
                # Lọc df_day theo ca thi hiện tại
                                df_shift = df_day[df_day['Ca thi'] == shift]
                                
                                df_time=df_shift['Giờ thi'].iloc(0)
                #
                                df_course = len(df_shift['Mã học phần'].unique())
                # Đếm số phòng thi của ca thi
                                num_rooms = len(df_shift['Mã phòng'].unique())

                # Hiển thị số phòng thi của ca thi
                                self.textEdit.insertPlainText(f"      Ca thi: {shift}, Tổng số học phần thi: {df_course}, Tổng số phòng thi được sử dụng: {num_rooms}\n")

                        day_count += 1
                # Xuống dòng sau khi kết thúc thông tin về mỗi ngày thi
                
                self.textEdit.insertPlainText("\n")
        def save_data_XLT(self):
                # Kiểm tra xem df_sv2ct và df_2 đã được khởi tạo chưa
                if self.df_cbdl is None:
                        QMessageBox.warning(None, "Lỗi", "Dữ liệu chưa được tải")
                        return
  
                
                # Mở hộp thoại để chọn vị trí lưu file
                file_dialog = QFileDialog()
                file_path, _ = file_dialog.getSaveFileName(None, "Lưu file", "", "Excel Files (*.xlsx *.xls)")
                if not file_path:  # Kiểm tra nếu người dùng không chọn vị trí lưu file
                        QMessageBox.warning(self, "Lỗi", "Bạn chưa chọn vị trí để lưu tập tin. Vui lòng chọn một vị trí để lưu.")
                        return
                # Lưu dữ liệu đã xử lý ra file Excel
                self.df_cbdl_processed.to_excel(file_path, index=False)
import resources
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
